

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>geogenie.utils.data_structure &mdash; GeoGenIE 1.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=292eb321"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            GeoGenIE
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">GeoGenIE Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../geogenie.html">geogenie package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">GeoGenIE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">geogenie.utils.data_structure</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for geogenie.utils.data_structure</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;PYTHONWARNINGS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;ignore::RuntimeWarning&quot;</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pysam</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">kneed</span> <span class="kn">import</span> <span class="n">KneeLocator</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">clone</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">NMF</span><span class="p">,</span> <span class="n">PCA</span><span class="p">,</span> <span class="n">KernelPCA</span>
<span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">SimpleImputer</span>
<span class="kn">from</span> <span class="nn">sklearn.manifold</span> <span class="kn">import</span> <span class="n">MDS</span><span class="p">,</span> <span class="n">TSNE</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">pairwise_distances</span><span class="p">,</span> <span class="n">silhouette_score</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span><span class="p">,</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KernelDensity</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">PolynomialFeatures</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">DataLoader</span>

<span class="kn">from</span> <span class="nn">geogenie.outliers.detect_outliers</span> <span class="kn">import</span> <span class="n">GeoGeneticOutlierDetector</span>
<span class="kn">from</span> <span class="nn">geogenie.plotting.plotting</span> <span class="kn">import</span> <span class="n">PlotGenIE</span>
<span class="kn">from</span> <span class="nn">geogenie.samplers.samplers</span> <span class="kn">import</span> <span class="n">GeographicDensitySampler</span>
<span class="kn">from</span> <span class="nn">geogenie.utils.data</span> <span class="kn">import</span> <span class="n">CustomDataset</span>
<span class="kn">from</span> <span class="nn">geogenie.utils.exceptions</span> <span class="kn">import</span> <span class="p">(</span><span class="n">EmbeddingError</span><span class="p">,</span> <span class="n">InvalidInputShapeError</span><span class="p">,</span>
                                       <span class="n">InvalidSampleDataError</span><span class="p">,</span>
                                       <span class="n">OutlierDetectionError</span><span class="p">,</span>
                                       <span class="n">SampleOrderingError</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">geogenie.utils.scorers</span> <span class="kn">import</span> <span class="n">LocallyLinearEmbeddingWrapper</span>
<span class="kn">from</span> <span class="nn">geogenie.utils.transformers</span> <span class="kn">import</span> <span class="n">MCA</span><span class="p">,</span> <span class="n">MinMaxScalerGeo</span>
<span class="kn">from</span> <span class="nn">geogenie.utils.utils</span> <span class="kn">import</span> <span class="n">get_iupac_dict</span><span class="p">,</span> <span class="n">read_csv_with_dynamic_sep</span>


<div class="viewcode-block" id="DataStructure">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure">[docs]</a>
<span class="k">class</span> <span class="nc">DataStructure</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to hold data structure from input VCF file.</span>

<span class="sd">    High level class overview. Key class functionalities include data loading, preprocessing, transformation, and machine learning model preparation.</span>

<span class="sd">    Initialization and Data Parsing - It loads VCF (Variant Call Format) files using pysam, processes genotypes, and handles missing data.</span>

<span class="sd">    Data Transformation and Imputation - Implements methods for allele counting, imputing missing genotypes, normalizing data, and transforming genotypes to various encodings.</span>

<span class="sd">    Data Splitting - Facilitates splitting data into training, validation, and test sets.</span>

<span class="sd">    Outlier Detection - Includes methods for detecting and handling outliers in the data.</span>

<span class="sd">    Data Preprocessing and Embedding: The class contains methods for preprocessing data, including scaling, dimensionality reduction, and embedding using various techniques like PCA, t-SNE, MCA, etc.</span>

<span class="sd">    Data Analysis and Visualization - The script integrates with the geogenie library for tasks like outlier detection and plotting.</span>

<span class="sd">    Machine Learning and Data Loading - It includes functionalities for creating data loaders (using torch) and preparing datasets for machine learning tasks, with support for different data sampling strategies and weightings.</span>

<span class="sd">    Utility Methods - The script provides additional utility methods for tasks like reading GTseq data, setting parameters, and selecting optimal components for different data transformations.</span>

<span class="sd">    In summary, the script is designed for comprehensive genomic data analysis, offering capabilities for data loading, preprocessing, transformation, machine learning model preparation, and visualization. It is structured to handle data from VCF files, process it through various analytical and transformational steps, and prepare it for further analysis or machine learning tasks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vcf_file</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructor for DataStructure class.</span>

<span class="sd">        Args:</span>
<span class="sd">            vcf_file (str): VCF filename to load.</span>
<span class="sd">            verbose (bool): Whether to enable verbosity. Default is False.</span>
<span class="sd">            dtype (torch.dtype): Data type for tensors. Default is torch.float32.</span>
<span class="sd">            debug (bool): Whether to enable debug mode. Default is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcf_file</span> <span class="o">=</span> <span class="n">vcf_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="c1"># Attempt to load the VCF file with a fallback on decompression and</span>
        <span class="c1"># recompression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_vcf_file</span><span class="p">()</span>

        <span class="c1"># Continue with initialization after loading VCF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genotypes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_missing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_iupac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_genotypes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simputer</span> <span class="o">=</span> <span class="n">SimpleImputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;most_frequent&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">MinMaxScalerGeo</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_load_vcf_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tries to load the VCF file and handles decompression and recompression if necessary.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pysam.VariantFile: Loaded VCF file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pysam</span><span class="o">.</span><span class="n">VariantFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcf_file</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Encountered issue with VCF compression: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decompress_recompress_index_and_load_vcf</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_decompress_recompress_index_and_load_vcf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Decompresses, recompresses, indexes, and reloads the VCF file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pysam.VariantFile: Recompressed and reloaded VCF file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">decompressed_vcf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decompress_vcf</span><span class="p">()</span>
        <span class="n">recompressed_vcf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recompress_vcf</span><span class="p">(</span><span class="n">decompressed_vcf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index_vcf</span><span class="p">(</span><span class="n">recompressed_vcf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_decompressed_file</span><span class="p">(</span><span class="n">decompressed_vcf</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pysam</span><span class="o">.</span><span class="n">VariantFile</span><span class="p">(</span><span class="n">recompressed_vcf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_decompress_vcf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Decompresses the gzipped VCF file and returns the decompressed file path.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Path to the decompressed VCF file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">decompressed_vcf_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcf_file</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.gz&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="p">(</span>
            <span class="n">pysam</span><span class="o">.</span><span class="n">BGZFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcf_file</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">compressed_vcf</span><span class="p">,</span>
            <span class="nb">open</span><span class="p">(</span><span class="n">decompressed_vcf_file</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">decompressed_vcf</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">decompressed_vcf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">compressed_vcf</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Decompressed VCF file: </span><span class="si">{</span><span class="n">decompressed_vcf_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">decompressed_vcf_file</span>

    <span class="k">def</span> <span class="nf">_recompress_vcf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decompressed_vcf_file</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recompresses the VCF file using bgzip and returns the recompressed file path.</span>

<span class="sd">        Args:</span>
<span class="sd">            decompressed_vcf_file (str): Path to the decompressed VCF file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Path to the recompressed VCF file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dvcf</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">decompressed_vcf_file</span><span class="p">)</span>
        <span class="n">recompressed_vcf_file</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">dvcf</span><span class="o">.</span><span class="n">with_name</span><span class="p">(</span><span class="n">dvcf</span><span class="o">.</span><span class="n">stem</span> <span class="o">+</span> <span class="s2">&quot;_recompressed.vcf&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;.gz&quot;</span>
        <span class="p">)</span>
        <span class="k">with</span> <span class="p">(</span>
            <span class="nb">open</span><span class="p">(</span><span class="n">decompressed_vcf_file</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">decompressed_vcf</span><span class="p">,</span>
            <span class="n">pysam</span><span class="o">.</span><span class="n">BGZFile</span><span class="p">(</span><span class="n">recompressed_vcf_file</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">recompressed_vcf</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">recompressed_vcf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">decompressed_vcf</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recompressed VCF file: </span><span class="si">{</span><span class="n">recompressed_vcf_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">recompressed_vcf_file</span>

    <span class="k">def</span> <span class="nf">_index_vcf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recompressed_vcf_file</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Indexes the recompressed VCF file using tabix.</span>

<span class="sd">        Args:</span>
<span class="sd">            recompressed_vcf_file (str): Path to the recompressed VCF file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pysam</span><span class="o">.</span><span class="n">tabix_index</span><span class="p">(</span><span class="n">recompressed_vcf_file</span><span class="p">,</span> <span class="n">preset</span><span class="o">=</span><span class="s2">&quot;vcf&quot;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Indexed VCF file: </span><span class="si">{</span><span class="n">recompressed_vcf_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cleanup_decompressed_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decompressed_vcf_file</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes the decompressed VCF file to save space.</span>

<span class="sd">        Args:</span>
<span class="sd">            decompressed_vcf_file (str): Path to the decompressed VCF file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Path</span><span class="p">(</span><span class="n">decompressed_vcf_file</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Deleted decompressed VCF file: </span><span class="si">{</span><span class="n">decompressed_vcf_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parse_genotypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse genotypes from the VCF file and store them in a NumPy array.</span>

<span class="sd">        Also, create a boolean array indicating missing data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: A tuple containing genotypes array, missing data array, and IUPAC encoded genotypes array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">genotypes_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">iupac_alleles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_missing_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcf</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_biallelic</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
                <span class="n">genos</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">missing</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">alleles</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">record</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">genotype</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;GT&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span>
                    <span class="n">genos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">genotype</span><span class="p">)</span>
                    <span class="n">missing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">allele</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">allele</span> <span class="ow">in</span> <span class="n">genotype</span><span class="p">))</span>
                    <span class="n">alleles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span>
                <span class="n">genotypes_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">genos</span><span class="p">)</span>
                <span class="n">is_missing_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span>
                <span class="n">iupac_alleles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">map_alleles_to_iupac</span><span class="p">(</span><span class="n">alleles</span><span class="p">,</span> <span class="n">get_iupac_dict</span><span class="p">())</span>
                <span class="p">)</span>
        <span class="c1"># Convert lists to NumPy arrays for efficient computation</span>
        <span class="n">genotypes_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">genotypes_list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">is_missing_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">is_missing_list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">genotypes_iupac_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">iupac_alleles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">genotypes_array</span><span class="p">,</span> <span class="n">is_missing_array</span><span class="p">,</span> <span class="n">genotypes_iupac_array</span>

<div class="viewcode-block" id="DataStructure.map_alleles_to_iupac">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.map_alleles_to_iupac">[docs]</a>
    <span class="k">def</span> <span class="nf">map_alleles_to_iupac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alleles</span><span class="p">,</span> <span class="n">iupac_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maps a list of allele tuples to their corresponding IUPAC nucleotide codes.</span>

<span class="sd">        Args:</span>
<span class="sd">            alleles (List[tuple]): List of tuples representing alleles.</span>
<span class="sd">            iupac_dict (dict): Dictionary mapping allele tuples to IUPAC codes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[str]: List of IUPAC nucleotide codes corresponding to the alleles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mapped_codes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">allele_pair</span> <span class="ow">in</span> <span class="n">alleles</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">allele_pair</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Direct mapping for single alleles</span>
                <span class="n">code</span> <span class="o">=</span> <span class="n">iupac_dict</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">allele_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="s2">&quot;N&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ap</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">allele_pair</span> <span class="k">else</span> <span class="n">allele_pair</span>

                <span class="c1"># Sort the tuple for unordered pairs</span>
                <span class="n">sorted_pair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
                <span class="n">code</span> <span class="o">=</span> <span class="n">iupac_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sorted_pair</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">)</span>
            <span class="n">mapped_codes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mapped_codes</span></div>


<div class="viewcode-block" id="DataStructure.is_biallelic">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.is_biallelic">[docs]</a>
    <span class="k">def</span> <span class="nf">is_biallelic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if number of alleles is biallelic.</span>

<span class="sd">        Args:</span>
<span class="sd">            record (pysam.VariantRecord): A VCF record.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the record is biallelic, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span></div>


<div class="viewcode-block" id="DataStructure.define_params">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.define_params">[docs]</a>
    <span class="k">def</span> <span class="nf">define_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Defines and updates class attrubutes from an argparse.Namespace object.</span>

<span class="sd">        This method sets the class attributes based on the parameters provided in the argparse.Namespace object. It is used to update the class parameters with the values provided in the command-line arguments.</span>

<span class="sd">        Args:</span>
<span class="sd">            args (argparse.Namespace): Argument namespace containing the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">(</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataStructure.count_alleles">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.count_alleles">[docs]</a>
    <span class="k">def</span> <span class="nf">count_alleles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Count alleles for each SNP across all samples.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: 2D array of allele counts with shape (n_loci, 2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating allele counts.&quot;</span><span class="p">)</span>
        <span class="n">allele_counts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">snp_genotypes</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotypes</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># Initialize counts for two alleles</span>

            <span class="k">for</span> <span class="n">genotype</span> <span class="ow">in</span> <span class="n">snp_genotypes</span><span class="p">:</span>
                <span class="c1"># Ensure the genotype is an integer array, handling missing data</span>
                <span class="n">int_genotype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">allele</span> <span class="k">if</span> <span class="n">allele</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">allele</span> <span class="ow">in</span> <span class="n">genotype</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="c1"># Count only valid alleles (0 or 1)</span>
                <span class="n">valid_alleles</span> <span class="o">=</span> <span class="n">int_genotype</span><span class="p">[</span><span class="n">int_genotype</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">counts</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">valid_alleles</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">allele_counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">allele_counts</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataStructure.impute_missing">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.impute_missing">[docs]</a>
    <span class="k">def</span> <span class="nf">impute_missing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">transform_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Impute missing genotypes based on allele frequency threshold.</span>

<span class="sd">        Args:</span>
<span class="sd">            X (numpy.ndarray): Data to impute.</span>
<span class="sd">            transform_only (bool): Whether to transform, but not fit. Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Imputed data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">transform_only</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidInputShapeError</span><span class="p">(</span>
                    <span class="s2">&quot;One of the input datasets was empty. Did you remember to set some values as unknown in the &#39;sample_data&#39; coordinates file?&quot;</span>
                <span class="p">)</span>
            <span class="n">imputed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simputer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simputer</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simputer</span><span class="p">)</span>
            <span class="n">imputed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>  <span class="c1"># ensure it&#39;s not fit.</span>
        <span class="k">return</span> <span class="n">imputed</span></div>


<div class="viewcode-block" id="DataStructure.sort_samples">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.sort_samples">[docs]</a>
    <span class="k">def</span> <span class="nf">sort_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_data_filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load sample_data and popmap and sort to match VCF file.</span>

<span class="sd">        Args:</span>
<span class="sd">            sample_data_filename (str): Filename of the sample data file.</span>

<span class="sd">        Raises:</span>
<span class="sd">            InvalidSampleDataError: If the sample data file format is incorrect.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span> <span class="o">=</span> <span class="n">read_csv_with_dynamic_sep</span><span class="p">(</span><span class="n">sample_data_filename</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&#39;sample_data&#39; must be a tab-delimited file with three columns: sampleID, x, and y. &#39;x&#39; and &#39;y&#39; should be longitude and latitude. However, we detected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> columns.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">InvalidSampleDataError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;sampleID&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="p">[</span><span class="s2">&quot;sampleID2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="p">[</span><span class="s2">&quot;sampleID&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;sampleID&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">))</span>

        <span class="c1"># Sample ordering check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_sample_ordering</span><span class="p">()</span>

        <span class="c1"># Ensure correct CRS.</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">processor</span><span class="o">.</span><span class="n">to_geopandas</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="p">[[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">processor</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sort_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sort_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_missing</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_missing</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_iupac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_iupac</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_iupac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_iupac</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_indices</span><span class="p">]</span></div>


<div class="viewcode-block" id="DataStructure.normalize_target">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.normalize_target">[docs]</a>
    <span class="k">def</span> <span class="nf">normalize_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">transform_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normalize locations, ignoring NaN.</span>

<span class="sd">        Args:</span>
<span class="sd">            y (numpy.ndarray): Array of locations to normalize.</span>
<span class="sd">            transform_only (bool): Whether to transform without fitting. Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Normalized locations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Normalizing coordinates...&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">transform_only</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Done normalizing coordinates.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">y</span></div>


    <span class="k">def</span> <span class="nf">_check_sample_ordering</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate sample ordering between &#39;sample_data&#39; and VCF files.</span>

<span class="sd">        Raises:</span>
<span class="sd">            SampleOrderingError: If the sample ordering is invalid after filtering and sorting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a set from sample_data for intersection check</span>
        <span class="n">sample_data_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="p">[</span><span class="s2">&quot;sampleID2&quot;</span><span class="p">])</span>

        <span class="c1"># Create mask for filtering samples present in both self.samples and self.sample_data</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">sample</span> <span class="ow">in</span> <span class="n">sample_data_set</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">]</span>

        <span class="c1"># Filter self.samples to those present in both lists and create a corresponding index list</span>
        <span class="n">filtered_samples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sort_indices</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[]</span>
        <span class="p">)</span>  <span class="c1"># This will store the indices that will be used to sort downstream objects</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">sample</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">sample_data_set</span><span class="p">:</span>
                <span class="n">filtered_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                <span class="n">sort_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="c1"># Filter and sort self.sample_data to only include rows with sampleID2 present in filtered_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="p">[</span><span class="s2">&quot;sampleID2&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">filtered_samples</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;sampleID2&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Sort filtered_samples to match the order in sorted self.sample_data</span>
        <span class="n">filtered_samples_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">filtered_samples</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="p">[</span><span class="s2">&quot;sampleID2&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Ensure that filtered_samples_sorted and self.sample_data are in the same order now</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="p">[</span><span class="s2">&quot;sampleID2&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filtered_samples_sorted</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Invalid sample ordering after filtering and sorting.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">SampleOrderingError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Compute sort_indices from self.samples based on</span>
        <span class="c1"># sorted filtered_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sort_indices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">==</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">filtered_samples_sorted</span>
        <span class="p">]</span>

        <span class="c1"># Store the mask and indices for later use in subsetting and</span>
        <span class="c1"># reordering other numpy arrays or objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_mask</span> <span class="o">=</span> <span class="n">mask</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Sample ordering, filtering mask, and sorting indices stored successfully.&quot;</span>
        <span class="p">)</span>

<div class="viewcode-block" id="DataStructure.snps_to_012">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.snps_to_012">[docs]</a>
    <span class="k">def</span> <span class="nf">snps_to_012</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_mac</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_snps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_values</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert IUPAC SNPs to 012 encodings.</span>

<span class="sd">        Args:</span>
<span class="sd">            min_mac (int): Minimum minor allele count. Default is 2.</span>
<span class="sd">            max_snps (int, optional): Maximum number of SNPs to retain.</span>
<span class="sd">            return_values (bool): Whether to return encoded values. Default is True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Encoded genotypes if return_values is True, otherwise updates internal state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Converting SNPs to 012-encodings.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">genotypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotypes</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genotypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotypes</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_indices</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">genotypes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">where</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genotypes</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">all_missing_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">all_missing_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">all_missing_mask</span><span class="p">]</span>

        <span class="n">allele_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">minlength</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">arr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_gt</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="p">,</span> <span class="n">min_mac</span><span class="p">,</span> <span class="n">max_snps</span><span class="p">,</span> <span class="n">allele_counts</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Input SNP data converted to 012-encodings.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Encoded Genotypes: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="o">.</span><span class="n">T</span><span class="si">}</span><span class="s2">, Shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">return_values</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="DataStructure.filter_gt">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.filter_gt">[docs]</a>
    <span class="k">def</span> <span class="nf">filter_gt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gt</span><span class="p">,</span> <span class="n">min_mac</span><span class="p">,</span> <span class="n">max_snps</span><span class="p">,</span> <span class="n">allele_counts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter genotypes based on minor allele count and random subsets (max_snps).</span>

<span class="sd">        Args:</span>
<span class="sd">            gt (numpy.ndarray): Genotypes to filter.</span>
<span class="sd">            min_mac (int): Minimum minor allele count.</span>
<span class="sd">            max_snps (int, optional): Maximum number of SNPs to retain.</span>
<span class="sd">            allele_counts (numpy.ndarray): Allele counts.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Filtered genotypes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">min_mac</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mac</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">allele_counts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">allele_counts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">gt</span> <span class="o">=</span> <span class="n">gt</span><span class="p">[</span><span class="n">mac</span> <span class="o">&gt;=</span> <span class="n">min_mac</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">if</span> <span class="n">max_snps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gt</span> <span class="o">=</span> <span class="n">gt</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">gt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">max_snps</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                <span class="p">:,</span>
            <span class="p">]</span>

        <span class="k">return</span> <span class="n">gt</span></div>


    <span class="k">def</span> <span class="nf">_find_optimal_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find optimnal number of clusters from input features.</span>

<span class="sd">        Args:</span>
<span class="sd">            features (numpy.ndarray): Input features.</span>
<span class="sd">            args (argparse.Namespace): Argument namespace containing additional parameters.</span>

<span class="sd">        Returns:</span>
<span class="sd">            optimal_k (int): Optimal number of clusters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_k</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">maxk</span>
        <span class="n">silhouette_scores</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
            <span class="n">silhouette_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">silhouette_score</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">))</span>

        <span class="n">optimal_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">silhouette_scores</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c1"># +2 to get the K value</span>
        <span class="k">return</span> <span class="n">optimal_k</span>

    <span class="k">def</span> <span class="nf">_determine_bandwidth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically determine the bandwidth for KernelDensity using cross-validation.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray | list): The data to estimate density.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Optimal bandwidth for KDE.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bandwidths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>  <span class="c1"># Test a range of bandwidths</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
            <span class="n">KernelDensity</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;haversine&quot;</span><span class="p">),</span>
            <span class="n">param_grid</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;bandwidth&quot;</span><span class="p">:</span> <span class="n">bandwidths</span><span class="p">},</span>
            <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">optimal_bandwidth</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">best_params_</span><span class="p">[</span><span class="s2">&quot;bandwidth&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Optimal bandwidth for KernelDensity: </span><span class="si">{</span><span class="n">optimal_bandwidth</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">optimal_bandwidth</span>

    <span class="k">def</span> <span class="nf">_determine_eps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Automatically determine the epsilon parameter for DBSCAN using k-distance.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray | list): The data to cluster.</span>
<span class="sd">            k (int): Number of nearest neighbors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Optimal eps for DBSCAN.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute pairwise distances</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">k_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span>
            <span class="p">:,</span> <span class="n">k</span>
        <span class="p">]</span>  <span class="c1"># k-th nearest neighbor distances</span>
        <span class="n">elbow_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span>
            <span class="n">k_distances</span><span class="p">,</span> <span class="mi">95</span>
        <span class="p">)</span>  <span class="c1"># Use the 95th percentile as heuristic</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimated epsilon (eps) for DBSCAN: </span><span class="si">{</span><span class="n">elbow_point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">elbow_point</span>

    <span class="c1"># Adjust the splits</span>
    <span class="k">def</span> <span class="nf">_adjust_splits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_split</span><span class="p">,</span> <span class="n">val_split</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjust train, validation, and test splits based on user input.</span>


<span class="sd">        Args:</span>
<span class="sd">            train_split (float): Proportion of the data to use for training.</span>
<span class="sd">            val_split (float): Proportion of the data to use for validation and test combined.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: Adjusted train, validation, and test splits.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">train_split</span> <span class="o">&gt;=</span> <span class="mf">1.0</span> <span class="ow">or</span> <span class="n">val_split</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;train_split and val_split must each be less than 1.0.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">train_split</span> <span class="o">+</span> <span class="n">val_split</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The sum of train_split and val_split must equal 1.0.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Remaining proportion after training split</span>
        <span class="n">remaining</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">train_split</span>

        <span class="c1"># Divide remaining proportion into validation and test splits</span>
        <span class="n">validation_split</span> <span class="o">=</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">*</span> <span class="n">val_split</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">test_split</span> <span class="o">=</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">*</span> <span class="n">val_split</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">train_split</span><span class="p">,</span> <span class="n">validation_split</span><span class="p">,</span> <span class="n">test_split</span>

<div class="viewcode-block" id="DataStructure.split_train_test">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.split_train_test">[docs]</a>
    <span class="k">def</span> <span class="nf">split_train_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_split</span><span class="p">,</span> <span class="n">val_split</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Splits the data into training, validation, and test datasets.</span>

<span class="sd">        Args:</span>
<span class="sd">            train_split (float): Proportion of the data to use for training.</span>
<span class="sd">            val_split (float): Proportion of the data to use for validation.</span>
<span class="sd">            seed (int): Random seed for reproducibility.</span>
<span class="sd">            args (argparse.Namespace): Argument namespace containing additional parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Splitting data into train, validation, and test datasets.&quot;</span>
            <span class="p">)</span>

        <span class="n">weighted_sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sample_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">weighted_sampler</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">weighted_sampler</span><span class="o">.</span><span class="n">weights</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">samples_weight</span> <span class="o">=</span> <span class="n">weights</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Splitting data into train, validation, and test datasets.&quot;</span>
            <span class="p">)</span>

        <span class="n">val_split</span> <span class="o">/=</span> <span class="mi">2</span>
        <span class="n">val_size</span> <span class="o">=</span> <span class="n">val_split</span> <span class="o">/</span> <span class="p">(</span><span class="n">train_split</span> <span class="o">+</span> <span class="n">val_split</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">train_split</span> <span class="o">+</span> <span class="n">val_split</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The sum of train_split and val_split must be &lt; 1.&quot;</span><span class="p">)</span>

        <span class="p">(</span>
            <span class="n">X_train_val</span><span class="p">,</span>
            <span class="n">X_test</span><span class="p">,</span>
            <span class="n">y_train_val</span><span class="p">,</span>
            <span class="n">y_test</span><span class="p">,</span>
            <span class="n">train_val_indices</span><span class="p">,</span>
            <span class="n">test_indices</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">train_size</span><span class="o">=</span><span class="n">train_split</span> <span class="o">+</span> <span class="n">val_split</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
            <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Ensure no overlap between train/val and test sets</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">train_val_indices</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
            <span class="n">test_indices</span>
        <span class="p">),</span> <span class="s2">&quot;Data leakage detected between train + val and test sets!&quot;</span>

        <span class="n">optimal_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_optimal_clusters</span><span class="p">(</span><span class="n">y_train_val</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">optimal_k</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">y_train_val</span><span class="p">)</span>

        <span class="n">X_train_val_list</span><span class="p">,</span> <span class="n">X_test_list</span><span class="p">,</span> <span class="n">X_train_list</span><span class="p">,</span> <span class="n">X_val_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">y_train_val_list</span><span class="p">,</span> <span class="n">y_test_list</span><span class="p">,</span> <span class="n">y_train_list</span><span class="p">,</span> <span class="n">y_val_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">train_val_indices_list</span><span class="p">,</span> <span class="n">val_indices_list</span><span class="p">,</span> <span class="n">test_indices_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">train_val_samples_list</span><span class="p">,</span> <span class="n">test_samples_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">train_val_weights_list</span><span class="p">,</span> <span class="n">test_weights_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">cluster_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">optimal_k</span><span class="p">):</span>
            <span class="n">cluster_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">cluster_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">)</span>
            <span class="n">cluster_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">)</span>

            <span class="n">split_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cluster_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">train_split</span> <span class="o">+</span> <span class="n">val_split</span><span class="p">))</span>

            <span class="n">train_val_indices_cluster</span> <span class="o">=</span> <span class="n">cluster_indices</span><span class="p">[:</span><span class="n">split_index</span><span class="p">]</span>
            <span class="n">test_indices_cluster</span> <span class="o">=</span> <span class="n">cluster_indices</span><span class="p">[</span><span class="n">split_index</span><span class="p">:]</span>

            <span class="n">X_train_val_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">train_val_indices_cluster</span><span class="p">])</span>
            <span class="n">y_train_val_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">train_val_indices_cluster</span><span class="p">])</span>
            <span class="n">train_val_indices_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">train_val_indices_cluster</span><span class="p">)</span>
            <span class="n">train_val_samples_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">train_val_indices_cluster</span><span class="p">])</span>
            <span class="n">train_val_weights_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">train_val_indices_cluster</span><span class="p">])</span>

            <span class="n">X_test_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">test_indices_cluster</span><span class="p">])</span>
            <span class="n">y_test_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">test_indices_cluster</span><span class="p">])</span>
            <span class="n">test_indices_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test_indices_cluster</span><span class="p">)</span>
            <span class="n">test_samples_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">test_indices_cluster</span><span class="p">])</span>
            <span class="n">test_weights_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">test_indices_cluster</span><span class="p">])</span>

        <span class="n">X_train_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">X_train_val_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">y_train_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">y_train_val_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">train_val_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">train_val_indices_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">X_test_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">y_test_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">test_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">test_indices_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">test_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">test_samples_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">test_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">test_weights_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="p">(</span>
            <span class="n">X_train</span><span class="p">,</span>
            <span class="n">X_val</span><span class="p">,</span>
            <span class="n">y_train</span><span class="p">,</span>
            <span class="n">y_val</span><span class="p">,</span>
            <span class="n">train_indices</span><span class="p">,</span>
            <span class="n">val_indices</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
            <span class="n">X_train_val</span><span class="p">,</span>
            <span class="n">y_train_val</span><span class="p">,</span>
            <span class="n">train_val_indices</span><span class="p">,</span>
            <span class="n">test_size</span><span class="o">=</span><span class="n">val_size</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
            <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Ensure no overlap between train and val sets</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">train_indices</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
            <span class="n">val_indices</span>
        <span class="p">),</span> <span class="s2">&quot;Data leakage detected between train and val sets!&quot;</span>

        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">use_gradient_boosting</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Gradient Boosting is not yet supported with clustering-based sampling.&quot;</span>
            <span class="p">)</span>
            <span class="p">(</span>
                <span class="n">X_val</span><span class="p">,</span>
                <span class="n">X_train_val</span><span class="p">,</span>
                <span class="n">y_val</span><span class="p">,</span>
                <span class="n">y_train_val</span><span class="p">,</span>
                <span class="n">train_indices</span><span class="p">,</span>
                <span class="n">train_val_indices</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">val_indices</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">optimal_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_optimal_clusters</span><span class="p">(</span><span class="n">y_train_val</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">optimal_k</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">y_train_val</span><span class="p">)</span>

        <span class="n">X_train_list</span><span class="p">,</span> <span class="n">y_train_list</span><span class="p">,</span> <span class="n">train_indices_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">X_val_list</span><span class="p">,</span> <span class="n">y_val_list</span><span class="p">,</span> <span class="n">val_indices_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">train_samples_list</span><span class="p">,</span> <span class="n">val_samples_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">train_weights_list</span><span class="p">,</span> <span class="n">val_weights_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">cluster_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">optimal_k</span><span class="p">):</span>
            <span class="n">cluster_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">cluster_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">)</span>
            <span class="n">split_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">train_split</span> <span class="o">/</span> <span class="p">(</span><span class="n">train_split</span> <span class="o">+</span> <span class="n">val_split</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">train_indices_cluster</span> <span class="o">=</span> <span class="n">cluster_indices</span><span class="p">[:</span><span class="n">split_index</span><span class="p">]</span>
            <span class="n">val_indices_cluster</span> <span class="o">=</span> <span class="n">cluster_indices</span><span class="p">[</span><span class="n">split_index</span><span class="p">:]</span>

            <span class="n">X_train_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">train_indices_cluster</span><span class="p">])</span>
            <span class="n">y_train_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">train_indices_cluster</span><span class="p">])</span>
            <span class="n">train_indices_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">train_indices_cluster</span><span class="p">)</span>
            <span class="n">train_samples_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">train_indices_cluster</span><span class="p">])</span>
            <span class="n">train_weights_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">train_indices_cluster</span><span class="p">])</span>

            <span class="n">X_val_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">val_indices_cluster</span><span class="p">])</span>
            <span class="n">y_val_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">val_indices_cluster</span><span class="p">])</span>
            <span class="n">val_indices_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val_indices_cluster</span><span class="p">)</span>
            <span class="n">val_samples_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">val_indices_cluster</span><span class="p">])</span>
            <span class="n">val_weights_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">val_indices_cluster</span><span class="p">])</span>

        <span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">X_train_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">y_train_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">train_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">train_indices_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">X_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">X_val_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">y_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">y_val_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">val_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">val_indices_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">train_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">train_samples_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">val_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">val_samples_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">train_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">train_weights_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">val_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">val_weights_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">train_samples</span> <span class="o">=</span> <span class="n">train_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val_samples</span> <span class="o">=</span> <span class="n">val_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_samples</span> <span class="o">=</span> <span class="n">test_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pred_indices</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">known_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">train_indices</span><span class="p">,</span> <span class="n">val_indices</span><span class="p">,</span> <span class="n">test_indices</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">known_indices</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;X_train&quot;</span><span class="p">:</span> <span class="n">X_train</span><span class="p">,</span>
            <span class="s2">&quot;X_val&quot;</span><span class="p">:</span> <span class="n">X_val</span><span class="p">,</span>
            <span class="s2">&quot;X_test&quot;</span><span class="p">:</span> <span class="n">X_test</span><span class="p">,</span>
            <span class="s2">&quot;X_pred&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_pred</span><span class="p">,</span>
            <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
            <span class="s2">&quot;y_train&quot;</span><span class="p">:</span> <span class="n">y_train</span><span class="p">,</span>
            <span class="s2">&quot;y_val&quot;</span><span class="p">:</span> <span class="n">y_val</span><span class="p">,</span>
            <span class="s2">&quot;y_test&quot;</span><span class="p">:</span> <span class="n">y_test</span><span class="p">,</span>
            <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
            <span class="s2">&quot;train_samples&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_samples</span><span class="p">,</span>
            <span class="s2">&quot;val_samples&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_samples</span><span class="p">,</span>
            <span class="s2">&quot;test_samples&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_samples</span><span class="p">,</span>
            <span class="s2">&quot;pred_samples&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_samples</span><span class="p">,</span>
            <span class="s2">&quot;known_samples&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">known_indices</span><span class="p">],</span>
            <span class="s2">&quot;train_weights&quot;</span><span class="p">:</span> <span class="n">train_weights</span><span class="p">,</span>
            <span class="s2">&quot;val_weights&quot;</span><span class="p">:</span> <span class="n">val_weights</span><span class="p">,</span>
            <span class="s2">&quot;test_weights&quot;</span><span class="p">:</span> <span class="n">test_weights</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">use_gradient_boosting</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;X_train_val&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">X_train_val</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;y_train_val&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_train_val</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;train_val_indices&quot;</span><span class="p">:</span> <span class="n">train_val_indices</span><span class="p">,</span>
            <span class="s2">&quot;train_indices&quot;</span><span class="p">:</span> <span class="n">train_indices</span><span class="p">,</span>
            <span class="s2">&quot;val_indices&quot;</span><span class="p">:</span> <span class="n">val_indices</span><span class="p">,</span>
            <span class="s2">&quot;test_indices&quot;</span><span class="p">:</span> <span class="n">test_indices</span><span class="p">,</span>
            <span class="s2">&quot;pred_indices&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_indices</span><span class="p">,</span>
            <span class="s2">&quot;true_indices&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_indices</span><span class="p">,</span>
            <span class="s2">&quot;known_indices&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">known_indices</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">use_gradient_boosting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="s2">&quot;train_val_indices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_val_indices</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Created train, validation, and test datasets.&quot;</span><span class="p">)</span>

        <span class="n">gdf_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">processor</span><span class="o">.</span><span class="n">to_geopandas</span><span class="p">(</span><span class="n">y_train</span><span class="p">)</span>
        <span class="n">gdf_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">processor</span><span class="o">.</span><span class="n">to_geopandas</span><span class="p">(</span><span class="n">y_val</span><span class="p">)</span>
        <span class="n">gdf_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">processor</span><span class="o">.</span><span class="n">to_geopandas</span><span class="p">(</span><span class="n">y_test</span><span class="p">)</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">processor</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">gdf_train</span><span class="p">)</span>
        <span class="n">y_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">processor</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">gdf_val</span><span class="p">)</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">processor</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">gdf_test</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Data Dictionary Object Shapes: </span><span class="se">{{</span><span class="s2">str(k): v.shape for k, v in self.data.items()</span><span class="se">}}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;All indices object shapes: </span><span class="se">{{</span><span class="s2">str(k): v.shape for k, v in self.indices.items()</span><span class="se">}}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Visualize results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">plot_scatter_samples_map</span><span class="p">(</span>
            <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="n">hue1</span><span class="o">=</span><span class="n">train_weights</span><span class="p">,</span> <span class="n">hue2</span><span class="o">=</span><span class="n">test_weights</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">plot_scatter_samples_map</span><span class="p">(</span>
            <span class="n">y_train</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="s2">&quot;val&quot;</span><span class="p">,</span> <span class="n">hue1</span><span class="o">=</span><span class="n">train_weights</span><span class="p">,</span> <span class="n">hue2</span><span class="o">=</span><span class="n">val_weights</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Train Dataset Size: </span><span class="si">{</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Validation Dataset Size: </span><span class="si">{</span><span class="n">X_val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Test Dataset Size: </span><span class="si">{</span><span class="n">X_test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Train Weights Size: </span><span class="si">{</span><span class="n">train_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Validation Weights Size: </span><span class="si">{</span><span class="n">val_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Test Weights Size: </span><span class="si">{</span><span class="n">test_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Known Indices Size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">known_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Train Indices Size: </span><span class="si">{</span><span class="n">train_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Validation Indices Size: </span><span class="si">{</span><span class="n">val_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Test Indices Size: </span><span class="si">{</span><span class="n">test_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;True Indices Size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">true_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Predicted Indices Size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pred_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Train Samples Size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">train_samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Validation Samples Size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">val_samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Test Samples Size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">test_samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Predicted Samples Size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pred_samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataStructure.map_outliers_through_filters">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.map_outliers_through_filters">[docs]</a>
    <span class="k">def</span> <span class="nf">map_outliers_through_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_indices</span><span class="p">,</span> <span class="n">filter_stages</span><span class="p">,</span> <span class="n">outliers</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maps outlier indices through multiple filtering stages back to the original dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            original_indices (np.ndarray): Array of original indices before any filtering.</span>
<span class="sd">            filter_stages (List[np.ndarray]): List of arrays of indices after each filtering stage.</span>
<span class="sd">            outliers (np.ndarray): Outlier indices in the most filtered dataset.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Mapped outlier indices in the original dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_indices</span> <span class="o">=</span> <span class="n">outliers</span>
        <span class="k">for</span> <span class="n">stage_indices</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">filter_stages</span><span class="p">):</span>
            <span class="n">current_indices</span> <span class="o">=</span> <span class="n">stage_indices</span><span class="p">[</span><span class="n">current_indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">original_indices</span><span class="p">[</span><span class="n">current_indices</span><span class="p">]</span></div>


<div class="viewcode-block" id="DataStructure.load_and_preprocess_data">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.load_and_preprocess_data">[docs]</a>
    <span class="k">def</span> <span class="nf">load_and_preprocess_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrapper method to load and preprocess data.</span>

<span class="sd">        Code execution order is listed below.</span>

<span class="sd">        Sample Data Loading and Sorting - Calls `self.sort_samples` with `args.sample_data` to load and sort sample data. This step involves reading sample data, presumably including their geographical locations, and aligning them with the genomic data.</span>

<span class="sd">        SNP Encoding Transformation - Transforms Single Nucleotide Polymorphisms (SNPs) into a 0,1,2 encoding format using self.snps_to_012, considering parameters like min_mac (minimum minor allele count) and max_snps (maximum number of SNPs).</span>

<span class="sd">        Validation of Feature and Target Lengths - Ensures that the feature data (X) and target data (y) have the same number of rows using self.validate_feature_target_len.</span>

<span class="sd">        Missing Data Imputation on full dataset - Imputes missing data in `self.genotypes_enc` using `self.impute_missing`.</span>

<span class="sd">        Data Embedding and Transformation - Performs an embedding transformation (like PCA) on the imputed data (X) using self.embed, with full_dataset_only=True and transform_only=False.</span>

<span class="sd">        Index Mask Setup - Defines masks for prediction (self.pred_mask) to identify samples with known and unknown locations. Sets up index masks for data using self.setup_index_masks.</span>

<span class="sd">        Outlier Detection (Conditional) - If args.detect_outliers is True, performs outlier detection using self.run_outlier_detection.</span>

<span class="sd">        Extract datasets - self.X, self.y, self.X_pred, self.true_idx, self.all_samples, self.samples, self.pred_samples, self.outlier_samples, self.non_outlier_samples = self.extract_datasets(all_outliers, args)</span>

<span class="sd">        Plotting Outliers (Conditional) - If outliers are detected, plots the outliers using self.plotting.plot_outliers.</span>

<span class="sd">        Data Normalization (Placeholder) - Normalizes the target data (y) using self.normalize_target with placeholder=True. This does nothing, unless `placeholder=False`.</span>

<span class="sd">        Splitting into Train, Test, and Validation Sets - Splits the dataset into training, validation, and testing sets using self.split_train_test.</span>

<span class="sd">        Feature Embedding for Train, Validation, and Test Sets (Conditional) - `args.embedding_type` is not `none`, embeds the features of training, validation, and test sets using `self.embed`.</span>

<span class="sd">        Logging Data Split and DataLoader Creation - Logs the completion of data splitting and the start of DataLoader creation, if verbosity is enabled.</span>

<span class="sd">        DataLoader Creation - Creates DataLoaders for training, validation, and test datasets using `self.call_create_dataloaders`. Additional DataLoader is created for gradient boosting if args.use_gradient_boosting is True. Logging Completion of Preprocessing Logs the successful completion of data loading and preprocessing, if verbosity is enabled.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span> <span class="o">=</span> <span class="n">PlotGenIE</span><span class="p">(</span>
            <span class="s2">&quot;cpu&quot;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span>
            <span class="n">args</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span>
            <span class="n">args</span><span class="o">.</span><span class="n">basemap_fips</span><span class="p">,</span>
            <span class="n">args</span><span class="o">.</span><span class="n">highlight_basemap_counties</span><span class="p">,</span>
            <span class="n">args</span><span class="o">.</span><span class="n">shapefile</span><span class="p">,</span>
            <span class="n">show_plots</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">show_plots</span><span class="p">,</span>
            <span class="n">fontsize</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">fontsize</span><span class="p">,</span>
            <span class="n">filetype</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">filetype</span><span class="p">,</span>
            <span class="n">dpi</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">plot_dpi</span><span class="p">,</span>
            <span class="n">remove_splines</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">remove_splines</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Loading and preprocessing input data...&quot;</span><span class="p">)</span>

        <span class="c1"># Load and sort sample data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sort_samples</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">sample_data</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">snps_to_012</span><span class="p">(</span>
            <span class="n">min_mac</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">min_mac</span><span class="p">,</span> <span class="n">max_snps</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">max_SNPs</span><span class="p">,</span> <span class="n">return_values</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="n">dfX</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="p">)</span>
            <span class="n">dfy</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">])</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">dfX</span><span class="p">,</span> <span class="n">dfy</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s2">&quot;geogenie/test/X_mod.csv&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Make sure features and target have same number of rows.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate_feature_target_len</span><span class="p">()</span>

        <span class="c1"># Impute missing data and embed.</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">impute_missing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="p">)</span>

        <span class="c1"># Define true_indices and pred_indices</span>
        <span class="c1"># If users did not supply any unknowns, randomly choose here.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">)):</span>  <span class="c1"># User supplied unknowns.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pred_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># User did not supply unknown values. Randomly Choose.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generate_unknowns</span><span class="p">(</span>
                <span class="n">p</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">prop_unknowns</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">seed</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Pred Mask: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pred_mask</span><span class="si">}</span><span class="s2">, Pred Mask Shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pred_mask</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">all_missing_mask</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mask: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="si">}</span><span class="s2">, Mask Shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">X</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_index_masks</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">true_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pred_mask</span><span class="p">]</span>  <span class="c1"># True if is not nan.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">pred_mask</span><span class="p">]</span>  <span class="c1"># True if is nan.</span>

        <span class="n">filter_stage_indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">true_indices</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pred_mask</span><span class="p">)</span><span class="si">}</span><span class="s2"> known samples and </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">pred_mask</span><span class="p">)</span><span class="si">}</span><span class="s2"> samples to predict.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Invalid input shapes for X and y. The number of rows (samples) must be equal, but got: </span><span class="si">{</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">all_outliers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">detect_outliers</span><span class="p">:</span>
            <span class="n">all_outliers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_outlier_detection</span><span class="p">(</span>
                <span class="n">args</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">filter_stage_indices</span>
            <span class="p">)</span>

        <span class="c1"># Here X has not been imputed.</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>  <span class="c1"># Known features only</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>  <span class="c1"># Knowns labels only</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X_pred</span><span class="p">,</span>  <span class="c1"># Unknown features only</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">true_idx</span><span class="p">,</span>  <span class="c1"># Known indices only</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_samples</span><span class="p">,</span>  <span class="c1"># All samples.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span>  <span class="c1"># Non-outliers + knowns</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pred_samples</span><span class="p">,</span>  <span class="c1"># Unknowns only.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outlier_samples</span><span class="p">,</span>  <span class="c1"># Only outliers.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">non_outlier_samples</span><span class="p">,</span>  <span class="c1"># Only non-outliers.</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_datasets</span><span class="p">(</span><span class="n">all_outliers</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">detect_outliers</span><span class="p">:</span>
            <span class="c1"># Write outlier samples to file.</span>
            <span class="n">outlier_fn</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">prefix</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_detected_outliers.txt&quot;</span>
            <span class="n">outlier_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outlier_dir</span> <span class="o">/</span> <span class="n">outlier_fn</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fout</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outlier_samples</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="n">outdata</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outlier_samples</span><span class="p">)</span>
                <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outdata</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> samples remaining after removing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_outliers</span><span class="p">)</span><span class="si">}</span><span class="s2"> outliers and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_pred</span><span class="p">)</span><span class="si">}</span><span class="s2"> samples with unknown localities.&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">plot_outliers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">)</span>

        <span class="c1"># placeholder=True makes it not do transform.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_train_test</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">train_split</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">val_split</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">seed</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">args</span><span class="o">.</span><span class="n">embedding_type</span> <span class="o">!=</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Embedding input features...&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;y_train&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_target</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;y_train&quot;</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">):</span>
                <span class="n">tonly</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;X_train&quot;</span> <span class="k">else</span> <span class="kc">True</span>

                <span class="c1"># Impute missing values.</span>
                <span class="n">imputed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">impute_missing</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">transform_only</span><span class="o">=</span><span class="n">tonly</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embed</span><span class="p">(</span>
                    <span class="n">args</span><span class="p">,</span>
                    <span class="n">X</span><span class="o">=</span><span class="n">imputed</span><span class="p">,</span>
                    <span class="n">alg</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">embedding_type</span><span class="p">,</span>
                    <span class="n">transform_only</span><span class="o">=</span><span class="n">tonly</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">):</span>
                <span class="n">tonly</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;y_train&quot;</span> <span class="k">else</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">tonly</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_target</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">transform_only</span><span class="o">=</span><span class="n">tonly</span><span class="p">)</span>

        <span class="c1"># For bootstrapping with unknown predictions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc_imp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simputer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc_imp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embed</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc_imp</span><span class="p">,</span> <span class="n">alg</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">embedding_type</span><span class="p">,</span> <span class="n">transform_only</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Encoded and Imputed Genotypes: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc_imp</span><span class="si">}</span><span class="s2">, Shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc_imp</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">args</span><span class="o">.</span><span class="n">embedding_type</span> <span class="o">!=</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finished embedding features!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Data split into train, val, and test sets.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Creating DataLoader objects...&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Training Features: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;X_train&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, Training Features Shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;X_train&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Validation Features: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;X_val&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, Validation Featurs Shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;X_val&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Test Features: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;X_test&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, Test Features Shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;X_test&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Training Targets: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;y_train&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, Training Target Shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;y_train&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Validation Targets: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;y_val&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, Validation Target Shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;y_val&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Test Targets: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;y_test&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, Test Target Shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;y_test&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Creating DataLoaders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_loader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_create_dataloaders</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;X_train&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;y_train&quot;</span><span class="p">],</span>
            <span class="n">args</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;train_samples&quot;</span><span class="p">],</span>
            <span class="n">dataset</span><span class="o">=</span><span class="s2">&quot;train&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val_loader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_create_dataloaders</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;X_val&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;y_val&quot;</span><span class="p">],</span>
            <span class="n">args</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;val_samples&quot;</span><span class="p">],</span>
            <span class="n">dataset</span><span class="o">=</span><span class="s2">&quot;val&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_loader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_create_dataloaders</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;X_test&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;y_test&quot;</span><span class="p">],</span>
            <span class="n">args</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;test_samples&quot;</span><span class="p">],</span>
            <span class="n">dataset</span><span class="o">=</span><span class="s2">&quot;test&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Plot dataset distributions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">plot_data_distributions</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;X_train&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;X_val&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;X_test&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">plot_data_distributions</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;y_train&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;y_val&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;y_test&quot;</span><span class="p">],</span>
            <span class="n">is_target</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">use_gradient_boosting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_val_loader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_create_dataloaders</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;X_train_val&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;y_train_val&quot;</span><span class="p">],</span>
                <span class="n">args</span><span class="p">,</span>
                <span class="kc">True</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;train_samples&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;val_samples&quot;</span><span class="p">],</span>
                <span class="n">dataset</span><span class="o">=</span><span class="s2">&quot;train_val&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;DataLoaders created succesfully!&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Data loading and preprocessing completed!&quot;</span><span class="p">)</span>

        <span class="c1"># For setting new prefix.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_loci</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;X_train&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Number of samples in train dataset: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;X_train&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Number of samples in validation dataset: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;X_val&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Number of samples in test dataset: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;X_test&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Number of samples in prediction dataset: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;X_pred&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Number of samples in train weights: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;train_weights&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Number of samples in validation weights: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;val_weights&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Number of samples in test weights: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;test_weights&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_N</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="si">}</span><span class="s2">_L</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_loci</span><span class="si">}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="DataStructure.generate_unknowns">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.generate_unknowns">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_unknowns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Randomly choose unknown samples for prediction.</span>

<span class="sd">        Only gets used if user does not supply and unkowns.</span>

<span class="sd">        Args:</span>
<span class="sd">            p (float): Proportion of samples to randomly select for the unknown prediction dataset. Defaults to 0.1.</span>
<span class="sd">            seed (int or None): Random seed to use for the random choice generator. Defaults to None (no random seed supplied).</span>
<span class="sd">            verbose (bool): Whether in verbose mode. Defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Unknown &#39;nan&#39; values were not provided in the &#39;--sample_data&#39; file. Randomly selecting </span><span class="si">{</span><span class="n">p</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">}</span><span class="s2"> percent of the samples (N=</span><span class="si">{</span><span class="n">p</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">)</span><span class="si">}</span><span class="s2"> samples) for the unknown prediction dataset.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">)</span>  <span class="c1"># Number of rows in pred_mask.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">pred_idx</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
            <span class="n">a</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">N</span><span class="p">)),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred_mask</span><span class="p">[</span><span class="n">pred_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="DataStructure.extract_datasets">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.extract_datasets">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_datasets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outliers</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts and separates datasets into known and predicted sets based on the presence of missing data.</span>

<span class="sd">        Args:</span>
<span class="sd">            outliers (numpy.ndarray): Array of outlier indices.</span>
<span class="sd">            args (argparse.Namespace): User-supplied arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: Extracted datasets and sample indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_indices</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">pred_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_indices</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">pred_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_indices</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">detect_outliers</span><span class="p">:</span>
            <span class="n">outlier_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">outlier_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_indices</span><span class="p">,</span> <span class="n">outliers</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">outlier_mask</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># remove outliers.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outlier_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="p">:],</span>  <span class="c1"># Knowns only.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="p">:],</span>  <span class="c1"># Knowns only.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="p">[</span><span class="n">pred_mask</span><span class="p">,</span> <span class="p">:],</span>  <span class="c1"># Unknowns only.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">],</span>  <span class="c1"># Knowns only.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span>  <span class="c1"># All samples.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">],</span>  <span class="c1"># no outliers + knowns.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">pred_mask</span><span class="p">],</span>  <span class="c1"># outliers + unknowns only.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">outlier_mask</span><span class="p">],</span>  <span class="c1"># only outliers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="o">~</span><span class="n">outlier_mask</span><span class="p">],</span>  <span class="c1"># only non-outliers</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DataStructure.validate_feature_target_len">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.validate_feature_target_len">[docs]</a>
    <span class="k">def</span> <span class="nf">validate_feature_target_len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate that the feature and target datasets have the same length.</span>

<span class="sd">        Raises:</span>
<span class="sd">            InvalidInputShapeError: If the shapes of the feature and target datasets do not match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Invalid input shapes for genotypes and coorindates. The number of rows (samples) must be equal, but got: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">InvalidInputShapeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataStructure.setup_index_masks">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.setup_index_masks">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_index_masks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets up index masks for filtering the data.</span>

<span class="sd">        Args:</span>
<span class="sd">            X (numpy.ndarray): Feature data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: Filtered feature data, indices, target data, and sample indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pred_mask</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pred_mask</span><span class="p">,</span> <span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">all_missing_mask</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pred_mask</span><span class="p">]</span>  <span class="c1"># Non-unknowns.</span>

        <span class="c1"># Store indices after filtering for nan</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">index</span></div>


<div class="viewcode-block" id="DataStructure.run_outlier_detection">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.run_outlier_detection">[docs]</a>
    <span class="k">def</span> <span class="nf">run_outlier_detection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">filter_stage_indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs outlier detection using geographic and genetic criteria.</span>

<span class="sd">        Args:</span>
<span class="sd">            args (argparse.Namespace): User-supplied arguments.</span>
<span class="sd">            X (numpy.ndarray): Feature matrix.</span>
<span class="sd">            indices (numpy.ndarray): Indices of samples.</span>
<span class="sd">            y (numpy.ndarray): Target variable (coordinates).</span>
<span class="sd">            index (numpy.ndarray): Index array for samples.</span>
<span class="sd">            filter_stage_indices (List[np.ndarray]): List of filter stage indices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Array of outlier indices.</span>

<span class="sd">        Raises:</span>
<span class="sd">            OutlierDetectionError: If an error occurs during outlier detection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">outlier_detector</span> <span class="o">=</span> <span class="n">GeoGeneticOutlierDetector</span><span class="p">(</span>
                <span class="n">args</span><span class="p">,</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">),</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">),</span>
                <span class="n">output_dir</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span>
                <span class="n">prefix</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="n">url</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">shapefile</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                <span class="n">show_plots</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">show_plots</span><span class="p">,</span>
                <span class="n">seed</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">seed</span><span class="p">,</span>
                <span class="n">debug</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">outliers</span> <span class="o">=</span> <span class="n">outlier_detector</span><span class="o">.</span><span class="n">composite_outlier_detection</span><span class="p">(</span>
                <span class="n">sig_level</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">significance_level</span><span class="p">,</span>
                <span class="n">maxk</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">maxk</span><span class="p">,</span>
                <span class="n">min_nn_dist</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">min_nn_dist</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">all_outliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">outliers</span><span class="p">[</span><span class="s2">&quot;geographic&quot;</span><span class="p">],</span> <span class="n">outliers</span><span class="p">[</span><span class="s2">&quot;genetic&quot;</span><span class="p">]))</span>

            <span class="c1"># Returns outiler indices, remapped.</span>
            <span class="n">mapped_all_outliers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_outliers_through_filters</span><span class="p">(</span>
                <span class="n">indices</span><span class="p">,</span> <span class="n">filter_stage_indices</span><span class="p">,</span> <span class="n">all_outliers</span>
            <span class="p">)</span>

            <span class="c1"># Remove mapped outliers from data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_indices</span><span class="p">,</span> <span class="n">mapped_all_outliers</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="n">all_outliers</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OutlierDetectionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error occurred during outlier detection: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataStructure.call_create_dataloaders">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.call_create_dataloaders">[docs]</a>
    <span class="k">def</span> <span class="nf">call_create_dataloaders</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">is_val</span><span class="p">,</span> <span class="n">sample_ids</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper method to create DataLoader objects for different datasets.</span>

<span class="sd">        Args:</span>
<span class="sd">            X (numpy.ndarray | list): Feature data.</span>
<span class="sd">            y (numpy.ndarray | None): Target data.</span>
<span class="sd">            args (argparse.Namespace): User-supplied arguments.</span>
<span class="sd">            is_val (bool): Whether the dataset is validation and test data. Default is False.</span>
<span class="sd">            sample_ids (List[str]): List of sample IDs. Default is None.</span>
<span class="sd">            dataset (str): Dataset type. Required keyword argument. Default is None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.utils.data.DataLoader: DataLoader object.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If sampleIDs are not provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sample_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Sample IDs must be provided to create DataLoader objects.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dataset</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;train&quot;</span><span class="p">,</span> <span class="s2">&quot;val&quot;</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="s2">&quot;train_val&quot;</span><span class="p">}:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Invalid dataset type. Must be one of &#39;train&#39;, &#39;val&#39;, &#39;test&#39;, or &#39;train_val&#39;.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_dataloaders</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span>
            <span class="n">y</span><span class="p">,</span>
            <span class="n">args</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">args</span><span class="p">,</span>
            <span class="n">is_val</span><span class="o">=</span><span class="n">is_val</span><span class="p">,</span>
            <span class="n">sample_ids</span><span class="o">=</span><span class="n">sample_ids</span><span class="p">,</span>
            <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DataStructure.embed">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.embed">[docs]</a>
    <span class="nd">@np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;warn&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">embed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">args</span><span class="p">,</span>
        <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alg</span><span class="o">=</span><span class="s2">&quot;pca&quot;</span><span class="p">,</span>
        <span class="n">full_dataset_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">transform_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Embed SNP data using one of several dimensionality reduction techniques.</span>

<span class="sd">        Args:</span>
<span class="sd">            args (argparse.Namespace): User-supplied arguments.</span>
<span class="sd">            X (numpy.ndarray): Data to embed. If None, uses self.genotypes_enc. Default is None.</span>
<span class="sd">            alg (str): Algorithm to use. Default is &#39;pca&#39;.</span>
<span class="sd">            full_dataset_only (bool): If True, only embed and return full dataset. Default is False.</span>
<span class="sd">            transform_only (bool): If True, only transform without fitting. Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Embedded data.</span>

<span class="sd">        Raises:</span>
<span class="sd">            EmbeddingError: If the optimal number of components cannot be estimated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotypes_enc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">do_embed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">alg</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;polynomial&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">polynomial_degree</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Setting &#39;polynomial_degree&#39; &gt; 2 can lead to extremely large computational overhead. Do so at your own risk!!!&quot;</span>
                <span class="p">)</span>
            <span class="n">emb</span> <span class="o">=</span> <span class="n">PolynomialFeatures</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">polynomial_degree</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">alg</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span><span class="p">:</span>
            <span class="n">n_components</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">n_components</span>
            <span class="k">if</span> <span class="n">n_components</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">transform_only</span><span class="p">:</span>
                <span class="n">n_components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_pca_comp</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="n">emb</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">n_components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;n_componenets could not be estimated for PCA embedding.&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">EmbeddingError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Optimal number of pca components: </span><span class="si">{</span><span class="n">n_components</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
        <span class="k">elif</span> <span class="n">alg</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;kernelpca&quot;</span><span class="p">:</span>
            <span class="n">n_components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_num_pca_comp</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">emb</span> <span class="o">=</span> <span class="n">KernelPCA</span><span class="p">(</span>
                <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span>
                <span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;rbf&quot;</span><span class="p">,</span>
                <span class="n">remove_zero_eig</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">seed</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">n_components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;n_components could not be estimated for kernelpca embedding.&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">EmbeddingError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Optimal number of kernelpca components: </span><span class="si">{</span><span class="n">n_components</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="n">alg</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;nmf&quot;</span><span class="p">:</span>
            <span class="n">n_components</span><span class="p">,</span> <span class="n">recon_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_optimal_nmf_components</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">plot_nmf_error</span><span class="p">(</span><span class="n">recon_error</span><span class="p">,</span> <span class="n">n_components</span><span class="p">)</span>

            <span class="n">emb</span> <span class="o">=</span> <span class="n">NMF</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n_components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;n_components could not be estimated for NMF embedding.&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">EmbeddingError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimal number of NMF components: </span><span class="si">{</span><span class="n">n_components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">alg</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;mca&quot;</span><span class="p">:</span>
            <span class="n">n_components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perform_mca_and_select_components</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">args</span><span class="o">.</span><span class="n">embedding_sensitivity</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">n_components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;n_components could not be estimated for MCA embedding.&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">EmbeddingError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimal number of MCA components: </span><span class="si">{</span><span class="n">n_components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">emb</span> <span class="o">=</span> <span class="n">MCA</span><span class="p">(</span>
                <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span>
                <span class="n">n_iter</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
                <span class="n">check_input</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">seed</span><span class="p">,</span>
                <span class="n">one_hot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">alg</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;tsne&quot;</span><span class="p">:</span>
            <span class="c1"># TODO: Make T-SNE plot.</span>
            <span class="n">emb</span> <span class="o">=</span> <span class="n">TSNE</span><span class="p">(</span>
                <span class="n">n_components</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span>
                <span class="n">perplexity</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">perplexity</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">seed</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">alg</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;mds&quot;</span><span class="p">:</span>
            <span class="c1"># TODO: Make MDS plot.</span>
            <span class="n">emb</span> <span class="o">=</span> <span class="n">MDS</span><span class="p">(</span>
                <span class="n">n_components</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span>
                <span class="n">n_init</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">n_init</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">seed</span><span class="p">,</span>
                <span class="n">normalized_stress</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">alg</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;lle&quot;</span><span class="p">:</span>
            <span class="c1"># Non-linear dimensionality reduction.</span>
            <span class="c1"># default max_iter often doesn&#39;t converge.</span>
            <span class="n">emb</span> <span class="o">=</span> <span class="n">LocallyLinearEmbeddingWrapper</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;modified&quot;</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">seed</span>
            <span class="p">)</span>

            <span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;n_neighbors&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                    <span class="mi">5</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">maxk</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
                <span class="p">),</span>
                <span class="s2">&quot;n_components&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                    <span class="mi">2</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">maxk</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
                <span class="p">),</span>
            <span class="p">}</span>

            <span class="n">grid</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
                <span class="n">emb</span><span class="p">,</span>
                <span class="n">param_grid</span><span class="o">=</span><span class="n">param_grid</span><span class="p">,</span>
                <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">scoring</span><span class="o">=</span><span class="n">LocallyLinearEmbeddingWrapper</span><span class="o">.</span><span class="n">lle_reconstruction_scorer</span><span class="p">,</span>
                <span class="n">refit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">error_score</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>  <span class="c1"># metric is maximized.</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">alg</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="c1"># Use raw encoded data.</span>
            <span class="n">do_embed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid &#39;alg&#39; value pasesed to &#39;embed()&#39;: </span><span class="si">{</span><span class="n">alg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transform_only</span> <span class="ow">and</span> <span class="n">do_embed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">alg</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;lle&quot;</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                    <span class="n">grid</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emb</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">best_estimator_</span>
                <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Best parameters for lle embedding: </span><span class="si">{</span><span class="n">grid</span><span class="o">.</span><span class="n">best_params_</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Best score for lle embedding: </span><span class="si">{</span><span class="n">grid</span><span class="o">.</span><span class="n">best_score_</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emb</span> <span class="o">=</span> <span class="n">emb</span>

        <span class="k">if</span> <span class="n">do_embed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">full_dataset_only</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">alg</span> <span class="o">!=</span> <span class="s2">&quot;mca&quot;</span><span class="p">:</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emb</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">emb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emb</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">X</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">transform_only</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">alg</span> <span class="o">!=</span> <span class="s2">&quot;mca&quot;</span><span class="p">:</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emb</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">emb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emb</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">X</span>

            <span class="k">elif</span> <span class="n">transform_only</span><span class="p">:</span>
                <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emb</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">X</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="DataStructure.perform_mca_and_select_components">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.perform_mca_and_select_components">[docs]</a>
    <span class="k">def</span> <span class="nf">perform_mca_and_select_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_components_range</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform MCA on the provided data and select the optimal number of components.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (pd.DataFrame): The categorical data.</span>
<span class="sd">            n_components_range (list): The range of components to explore.</span>
<span class="sd">            S (float): Sensitivity setting for selecting optimal number of components.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The optimal number of components.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mca</span> <span class="o">=</span> <span class="n">MCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">n_components_range</span><span class="p">),</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">one_hot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mca</span> <span class="o">=</span> <span class="n">mca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">cumulative_inertia</span> <span class="o">=</span> <span class="n">mca</span><span class="o">.</span><span class="n">cumulative_inertia_</span>
        <span class="n">optimal_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_optimal_components</span><span class="p">(</span><span class="n">cumulative_inertia</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">plot_mca_curve</span><span class="p">(</span><span class="n">cumulative_inertia</span><span class="p">,</span> <span class="n">optimal_n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">optimal_n</span></div>


<div class="viewcode-block" id="DataStructure.select_optimal_components">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.select_optimal_components">[docs]</a>
    <span class="k">def</span> <span class="nf">select_optimal_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cumulative_inertia</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select the optimal number of components based on explained inertia.</span>

<span class="sd">        Args:</span>
<span class="sd">            cumulative_inertia (list): The cumulative inertia for each component.</span>
<span class="sd">            S (float): Sensitivity setting for selecting optimal number of components.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The optimal number of components.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kneedle</span> <span class="o">=</span> <span class="n">KneeLocator</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="n">cumulative_inertia</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">cumulative_inertia</span><span class="p">,</span>
            <span class="n">curve</span><span class="o">=</span><span class="s2">&quot;concave&quot;</span><span class="p">,</span>
            <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;increasing&quot;</span><span class="p">,</span>
            <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">optimal_n</span> <span class="o">=</span> <span class="n">kneedle</span><span class="o">.</span><span class="n">knee</span>
        <span class="k">return</span> <span class="n">optimal_n</span></div>


<div class="viewcode-block" id="DataStructure.find_optimal_nmf_components">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.find_optimal_nmf_components">[docs]</a>
    <span class="k">def</span> <span class="nf">find_optimal_nmf_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">min_components</span><span class="p">,</span> <span class="n">max_components</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the optimal number of components for NMF based on reconstruction error.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.array): The data to fit the NMF model.</span>
<span class="sd">            min_components (int): The minimum number of components to try.</span>
<span class="sd">            max_components (int): The maximum number of components to try.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: The optimal number of components and the reconstruction errors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">components_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_components</span><span class="p">,</span> <span class="n">max_components</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">components_range</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">NMF</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">reconstruction_err_</span><span class="p">)</span>

        <span class="n">optimal_n</span> <span class="o">=</span> <span class="n">components_range</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">errors</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">optimal_n</span><span class="p">,</span> <span class="n">errors</span></div>


<div class="viewcode-block" id="DataStructure.get_num_pca_comp">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.get_num_pca_comp">[docs]</a>
    <span class="k">def</span> <span class="nf">get_num_pca_comp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get optimal number of PCA components.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (numpy.ndarray): Dataset to fit PCA to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Optimal number of principal components to use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">vr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">vr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">eigenvalues_</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">eigenvalues_</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">kneedle</span> <span class="o">=</span> <span class="n">KneeLocator</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span>
            <span class="n">vr</span><span class="p">,</span>
            <span class="n">S</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">curve</span><span class="o">=</span><span class="s2">&quot;concave&quot;</span><span class="p">,</span>
            <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;increasing&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">knee</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">kneedle</span><span class="o">.</span><span class="n">knee</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">plot_pca_curve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">vr</span><span class="p">,</span> <span class="n">knee</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">knee</span></div>


<div class="viewcode-block" id="DataStructure.create_dataloaders">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.create_dataloaders">[docs]</a>
    <span class="k">def</span> <span class="nf">create_dataloaders</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">X</span><span class="p">,</span>
        <span class="n">y</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">,</span>
        <span class="n">args</span><span class="p">,</span>
        <span class="n">is_val</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sample_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dataset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create dataloaders for training, testing, and validation datasets.</span>

<span class="sd">        Args:</span>
<span class="sd">            X (numpy.ndarray | list): X dataset. Train, test, or validation.</span>
<span class="sd">            y (numpy.ndarray | None): Target data (train, test, or validation). None for GNN.</span>
<span class="sd">            batch_size (int): Batch size to use with model.</span>
<span class="sd">            args (argparse.Namespace): User-supplied arguments.</span>
<span class="sd">            is_val (bool): Whether using validation/ test dataset. Otherwise should be training dataset. Default is False.</span>
<span class="sd">            sample_ids (List[str]): List of sample IDs. Default is None.</span>
<span class="sd">            dataset (str): Dataset type. Required keyword argument. Default is None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.utils.data.DataLoader: DataLoader object suitable for the specified model type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sample_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Sample IDs must be provided to create DataLoader objects.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dataset</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;train&quot;</span><span class="p">,</span> <span class="s2">&quot;val&quot;</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="s2">&quot;train_val&quot;</span><span class="p">}:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Invalid dataset type. Must be one of &#39;train&#39;, &#39;val&#39;, &#39;test&#39;, or &#39;train_val&#39;.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;sample_ids&quot;</span><span class="p">:</span> <span class="n">sample_ids</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">is_val</span>
            <span class="k">else</span> <span class="p">{</span><span class="s2">&quot;sample_weights&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;train_weights&quot;</span><span class="p">]}</span>
        <span class="p">)</span>

        <span class="n">dataset</span> <span class="o">=</span> <span class="n">CustomDataset</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Create DataLoader</span>
        <span class="n">kwargs2</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;batch_size&quot;</span><span class="p">:</span> <span class="n">batch_size</span><span class="p">}</span>
        <span class="n">kwargs2</span><span class="p">[</span><span class="s2">&quot;shuffle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">is_val</span> <span class="k">else</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs2</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataStructure.get_sample_weights">
<a class="viewcode-back" href="../../../geogenie.utils.html#geogenie.utils.data_structure.DataStructure.get_sample_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">get_sample_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gets inverse sample_weights based on sampling density.</span>

<span class="sd">        Uses scikit-learn KernelDensity with a grid search to estimate the optimal bandwidth for GeographicDensitySampler.</span>

<span class="sd">        Args:</span>
<span class="sd">            y (numpy.ndarray): Target values.</span>
<span class="sd">            args (argparse.Namespace): User-supplied arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            GeographicDensitySampler: The weighted sampler with estimated sample weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize weighted sampler if class weights are used</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weighted_sampler</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">densities</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples_weight</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">use_weighted</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;sampler&quot;</span><span class="p">,</span> <span class="s2">&quot;loss&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">}:</span>
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Estimating sampling density weights...&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Searching for optimal weighted sampler kde bandwidth...&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Weight by sampling density.</span>
            <span class="n">weighted_sampler</span> <span class="o">=</span> <span class="n">GeographicDensitySampler</span><span class="p">(</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">]),</span>
                <span class="n">focus_regions</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">focus_regions</span><span class="p">,</span>
                <span class="n">use_kmeans</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">use_kmeans</span><span class="p">,</span>
                <span class="n">use_kde</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">use_kde</span><span class="p">,</span>
                <span class="n">use_dbscan</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">use_dbscan</span><span class="p">,</span>
                <span class="n">w_power</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">w_power</span><span class="p">,</span>
                <span class="n">max_clusters</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">max_clusters</span><span class="p">,</span>
                <span class="n">max_neighbors</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">max_neighbors</span><span class="p">,</span>
                <span class="n">normalize</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">normalize_sample_weights</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Done estimating sample weights.&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">weighted_sampler</span> <span class="o">=</span> <span class="n">weighted_sampler</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples_weight</span> <span class="o">=</span> <span class="n">weighted_sampler</span><span class="o">.</span><span class="n">weights</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples_weight_indices</span> <span class="o">=</span> <span class="n">weighted_sampler</span><span class="o">.</span><span class="n">indices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">densities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_sampler</span><span class="o">.</span><span class="n">density</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_sampler</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Getter for the params dictionary.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Parameters dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span>

    <span class="nd">@params</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the params dictionary.</span>

<span class="sd">        Args:</span>
<span class="sd">            value (dict): Dictionary to update params with.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Bradley T. Martin and Tyler K. Chafin.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>